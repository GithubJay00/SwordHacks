local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()


if game.GameId == 6361937392 then
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	game:GetService("ReplicatedFirst"):FindFirstChild("Static"):FindFirstChild("Superman").Parent = nil
	game:GetService("ReplicatedFirst"):FindFirstChild("Prod"):FindFirstChild("Stats").Parent = nil
	game:GetService("ReplicatedFirst"):FindFirstChild("Static"):FindFirstChild("UIScaleHandler").Parent = nil
end



getgenv().Settings = {
	
	ReachToggle = nil ,
	
	ReachType = "FireTouchInterest" ,

	Range = 6 ,
	
	ReachToggleVisualizer = nil ,
	
	SwordVisualColor = Color3.fromRGB(0, 0, 0) ,
	
	

	AmpToggle = nil , 

	Damage = 2 , 
	
	
	
	HitboxToggle = nil , 
	
	HitboxSize = 5.5 , 
	
	HitboxVisual = nil ,
	
	HitboxColor = Color3.fromRGB(0, 0, 0)
	
}



local VisualP = Instance.new("Part")
VisualP.Anchored = true
VisualP.CanCollide = false
VisualP.CastShadow = false
VisualP.Transparency = 0.9
VisualP.Material = Enum.Material.Neon
VisualP.Shape = "Ball"




local Window = Rayfield:CreateWindow({
	Name = "SwordHacks",
	Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
	LoadingTitle = "SwordHacks",
	LoadingSubtitle = "by aaa000798",
	ShowText = " ", -- for mobile users to unhide rayfield, change if you'd like
	Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

	ToggleUIKeybind = "K", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

	DisableRayfieldPrompts = true,
	DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

	ConfigurationSaving = {
		Enabled = false,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "SwordHacks"
	},

	Discord = {
		Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},

	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "Untitled",
		Subtitle = "Key System",
		Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})




local MainTab = Window:CreateTab("Main", nil) -- Title, Image


local ReachSection = MainTab:CreateSection("Reach")

local ReachToggleButton = MainTab:CreateToggle({
	Name = "Reach",
	CurrentValue = false,
	Flag = "ReachToggle", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(ReachToggleValue)
		Settings.ReachToggle = ReachToggleValue
	end,
})


local ReachDropdown = MainTab:CreateDropdown({
	Name = "Reach Type",
	Options = { "FireTouchInterest", "C-Bring" },
	CurrentOption = {"FireTouchInterest"},
	MultipleOptions = false,
	Flag = "ReachSelect", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(ReachOption)
		Settings.ReachType = ReachOption
	end,
})


local ReachSlider = MainTab:CreateSlider({
	Name = "Range",
	Range = {1, 20},
	Increment = 0.1,
	Suffix = "Radius",
	CurrentValue = 6,
	Flag = "RangeSlider", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(RangeValue)
		Settings.Range = RangeValue
	end,
})


local ReachVisualToggle = MainTab:CreateToggle({
	Name = "Reach Visualizer",
	CurrentValue = false,
	Flag = "VisualToggle", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(VisualValue)
		Settings.ReachToggleVisualizer = VisualValue
	end,
})


local ReachColorPicker = MainTab:CreateColorPicker({
	Name = "Color",
	Color = Color3.fromRGB(0, 0, 0),
	Flag = "SwordVisualColorPicker", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(SwordVisualColorValue)
		Settings.SwordVisualColor = SwordVisualColorValue
	end
})







local DamageSection = MainTab:CreateSection("Damage")

local DamageToggleButton = MainTab:CreateToggle({
	Name = "Damage",
	CurrentValue = false,
	Flag = "DamageToggle", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(DamageToggleValue)
		Settings.AmpToggle = DamageToggleValue
	end,
})


local DamageSlider = MainTab:CreateSlider({
	Name = "Damage Amount",
	Range = {1, 4},
	Increment = 1,
	Suffix = "X",
	CurrentValue = 2,
	Flag = "DamageSlider", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(DamageValue)
		Settings.Damage = DamageValue
	end,
})







local HitboxSection = MainTab:CreateSection("Hitbox")

local HitboxToggleButton = MainTab:CreateToggle({
	Name = "Hitbox Toggle",
	CurrentValue = false,
	Flag = "HitboxToggle", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(HitboxToggleValue)
		Settings.HitboxToggle = HitboxToggleValue
	end,
})


local HitboxSlider = MainTab:CreateSlider({
	Name = "Size",
	Range = {1, 20},
	Increment = 0.1,
	Suffix = "Htibox",
	CurrentValue = 5.5,
	Flag = "HitboxSlider", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(HitboxSliderValue)
		Settings.HitboxSize = HitboxSliderValue
	end,
})


local HitboxVisualToggle = MainTab:CreateToggle({
	Name = "Hitbox Visual",
	CurrentValue = false,
	Flag = "HitboxVisual", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(HitboxVisualValue)
		Settings.HitboxVisual = HitboxVisualValue
	end,
})

local HtiboxColorPicker = MainTab:CreateColorPicker({
	Name = "Hitbox Color",
	Color = Color3.fromRGB(0, 0, 0),
	Flag = "HitboxColor1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(HitbotColorValue)
		Settings.HitboxColor = HitbotColorValue
	end
})







local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer


RunService.Stepped:Connect(function()

	if Settings.ReachToggle then

		for _, p in pairs(Players:GetPlayers()) do
			if p.Name ~= player.Name then

				local qChar = p.Character
				local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")
				local qHM = qChar and qChar:FindFirstChildOfClass("Humanoid")

				local Char = player.Character
				local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
				local HM = Char and Char:FindFirstChildOfClass("Humanoid")

				if HM and qHM then
					if HM.Health > 0 and qHM.Health > 0 then


						local limbs1 = {
							RightArm = qChar:FindFirstChild("Right Arm") ,

							LeftArm = qChar:FindFirstChild("Left Arm") ,

							RightLeg = qChar:FindFirstChild("Right Leg") ,

							LeftLeg = qChar:FindFirstChild("Left Leg") ,

							Torso = qChar:FindFirstChild("Torso") ,

							HumanoidRootPart = qChar:FindFirstChild("HumanoidRootPart") ,

							Head = qChar:FindFirstChild("Head")
						}
						
						
						local limbs2 = {
							
							RightArm = qChar:FindFirstChild("Right Arm") ,

							LeftArm = qChar:FindFirstChild("Left Arm") ,

							RightLeg = qChar:FindFirstChild("Right Leg") ,

							LeftLeg = qChar:FindFirstChild("Left Leg") 

						}
						

						local tool = Char and Char:FindFirstChildOfClass("Tool")
						local Handle = tool and tool:FindFirstChild("Handle")

						if tool and Handle then

							local Distance = (Handle.Position - qHRP.Position).Magnitude
							if Distance <= Settings.Range then
								
								
								if Settings.ReachType == "FireTouchInterest" then
									
									local Qhrp = limbs1.HumanoidRootPart
									firetouchinterest(Qhrp, Handle, 0)
									firetouchinterest(Qhrp, Handle, 1)
									
									
								elseif Settings.ReachType == "C-Bring" then
									
									for _, limb in ipairs(limbs2) do
										if limb then
											limb:BreakJoints()
											limb.CFrame = Handle.CFrame
											limb.Anchored = true
											limb.Transparency = 1
										end
									end
								end
								
							end
						end
					end
				end
			end
		end
	end
end)



local function Whitelist()
	
	local WLD = {}
	
	for _, p in pairs(Players:GetPlayers()) do
		if p.Name ~= player.Name then
			
			local qchar = p.Character
			
			if qchar then
				
				for _, dta in pairs(qchar:GetChildren()) do
					if dta:IsA("BasePart") then
						
						table.insert(WLD, dta)
					end
				end
			end
		end
	end
	
	return WLD
end



RunService.Stepped:Connect(function()
	
	if Settings.AmpToggle then
		
		if Settings.ReachToggle then
			
			for _, p in pairs(Players:GetPlayers()) do
				if p.Name ~= player.Name then

					local qChar = p.Character
					local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")
					local qHM = qChar and qChar:FindFirstChildOfClass("Humanoid")

					local Char = player.Character
					local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
					local HM = Char and Char:FindFirstChildOfClass("Humanoid")

					if HM and qHM then
						if HM.Health > 0 and qHM.Health > 0 then

							local tool = Char and Char:FindFirstChildOfClass("Tool")
							local Handle = tool and tool:FindFirstChild("Handle")

							if tool and Handle then

								local Distance = (Handle.Position - qHRP.Position).Magnitude
								if Distance <= Settings.Range then
									
									for _, Child in pairs(qChar:GetChildren()) do
										for _ = 1, Settings.Damage do
											if Child:IsA("BasePart") then
												firetouchinterest(Child, Handle, 0)
												firetouchinterest(Child, Handle, 1)
												firetouchinterest(Child, Handle, 0)
											end
										end
									end
								end
							end
						end
					end
				end
			end
		else
			for _, p in pairs(Players:GetPlayers()) do
				if p.Name ~= player.Name then

					local qChar = p.Character
					local qHM = qChar and qChar:FindFirstChildOfClass("Humanoid")

					local Char = player.Character
					local HM = Char and Char:FindFirstChildOfClass("Humanoid")

					if HM and qHM then
						if HM.Health > 0 and qHM.Health > 0 then

							local tool = Char and Char:FindFirstChildOfClass("Tool")
							local Handle = tool and tool:FindFirstChild("Handle")

							if tool and Handle then
					
								for _, hit in pairs(Handle:GetTouchingParts()) do
									if hit == Whitelist() then
										
										for _, Child in pairs(qChar:GetChildren()) do
											for _ = 1, Settings.Damage do
												if Child:IsA("BasePart") then
													firetouchinterest(Child, Handle, 0)
													firetouchinterest(Child, Handle, 1)
													firetouchinterest(Child, Handle, 0)
												end
											end
										end
									end
								end
								
							end
						end
					end
				end
			end
		end
	end
end)




RunService.Stepped:Connect(function()
	if Settings.ReachToggle then
		
		local Character = player.Character

		local Tool = Character and Character:FindFirstChildOfClass("Tool")
		if not Tool then VisualP.Parent = nil end

		if Tool then
			local handle = Tool and Tool:FindFirstChild("Handle")

			if handle then

				if Settings.ReachToggleVisualizer then
					VisualP.Parent = workspace
					VisualP.Size = Vector3.new(Settings.Range, Settings.Range, Settings.Range)
					VisualP.CFrame = handle.CFrame
				else
					VisualP.Parent = nil
				end
			end
		end
	end
end)

RunService.RenderStepped:Connect(function()
	if VisualP then
		VisualP.Color = Settings.SwordVisualColor
	end
end)




RunService.Stepped:Connect(function()
	if Settings.HitboxToggle then
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name ~= player.Name then
				pcall(function()

					local qChar = p.Character
					local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")

					qHRP.Size = Vector3.new(Settings.HitboxSize, Settings.HitboxSize, Settings.HitboxSize)

					qHRP.CanCollide = false
					
				end)
			end
		end
	else
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name ~= player.Name then
				pcall(function()

					local qChar = p.Character
					local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")

					qHRP.Size = Vector3.new(2, 2, 1)

					qHRP.CanCollide = false

				end)
			end
		end
	end
end)


RunService.Stepped:Connect(function()
	
	if Settings.HitboxVisual then
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name ~= player.Name then
				pcall(function()
					local qChar = p.Character
					local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")

					qHRP.Transparency = 0.7
				end)
			end
		end
		
	else
		
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name ~= player.Name then
				pcall(function()
					local qChar = p.Character
					local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")

					qHRP.Transparency = 1
				end)
			end
		end
	end
	
end)

RunService.RenderStepped:Connect(function()
	for _, p in pairs(Players:GetPlayers()) do
		if p.Name ~= player.Name then
			pcall(function()
				local qChar = p.Character
				local qHRP = qChar and qChar:FindFirstChild("HumanoidRootPart")

				qHRP.Color = Settings.HitboxColor
			end)
		end
	end
end)






getgenv().Settings2 = {
	
	LungeBotToggled = nil ,
	LungeBotRange = 5 , 
	
	
	AimbotToggled = nil , 
	AimbotSliderValue = 5 ,
	AimbotTargetPart = "Torso" ,
	AimbotOffset = 0 ,
	
	
	JumpbotToggle = nil , 
	JumpbotRange = 5
	
}






local PlayerTab = Window:CreateTab("Player", nil) -- Title, Image




local BotsSection = PlayerTab:CreateSection("AutoBots")

local LungeToggle = PlayerTab:CreateToggle({
	Name = "Lunge Bot",
	CurrentValue = false,
	Flag = "LungeBotToggle", 
	Callback = function(LungeBotValue)
		Settings2.LungeBotToggled = LungeBotValue
	end,
})

local LungeBotSlider = PlayerTab:CreateSlider({
	Name = "Lunge Range",
	Range = {1, 100},
	Increment = 0.1,
	Suffix = "Range",
	CurrentValue = 5,
	Flag = "LungeBotSlider",
	Callback = function(LungeBotSliderValue)
		Settings2.LungeBotRange = LungeBotSliderValue
	end,
})





local JumpBotSection = PlayerTab:CreateSection("JumpBot")

local JumpBotToggleButton = PlayerTab:CreateToggle({
	Name = "Jumpbot",
	CurrentValue = false,
	Flag = "JumpbotToggle1", 
	Callback = function(JumpbotValue)
		Settings2.JumpbotToggle
	end,
})

local JumpBotSlider = PlayerTab:CreateSlider({
	Name = "Jump Range",
	Range = {1, 100},
	Increment = 0.1,
	Suffix = "Radius",
	CurrentValue = 5,
	Flag = "jumpbotSlider1", 
	Callback = function(JumpbotSliderValue)
		Settings2.JumpbotRange = JumpbotSliderValue
	end,
})





local AimbotSection = PlayerTab:CreateSection("Aimbot")

local AimbotToggle = PlayerTab:CreateToggle({
	Name = "Aimbot",
	CurrentValue = false,
	Flag = "AimbotToggle",
	Callback = function(AimbotToggleValue)
		Settings2.AimbotToggled = AimbotToggleValue
	end,
})

local AimbotPartDropDown = PlayerTab:CreateDropdown({
	Name = "Target Part",
	Options = { "Right Arm", "Torso", "Left Arm" },
	CurrentOption = {"Torso"},
	MultipleOptions = false,
	Flag = "TPartDropdown", 
	Callback = function(TargetPart)
		Settings2.AimbotTargetPart = TargetPart
	end,
})

local AimbotSlider = PlayerTab:CreateSlider({
	Name = "Aimbot radius",
	Range = {1, 100},
	Increment = 0.1,
	Suffix = "Distance",
	CurrentValue = 5,
	Flag = "AimbotSlider1", 
	Callback = function(AimbotDistanceValue)
		Settings2.AimbotSliderValue = AimbotDistanceValue
	end,
})

local AimbotOffsetSlider = PlayerTab:CreateSlider({
	Name = "Aimbot Offset",
	Range = {0, 100},
	Increment = 0.1,
	Suffix = "Offset",
	CurrentValue = 0,
	Flag = "AimbotOffsetSlider", 
	Callback = function(AimbotOffsetValue)
		Settings2.AimbotOffset = AimbotOffsetValue
	end,
})







RunService.Heartbeat:Connect(function()
	if Settings2.LungeBotToggled then
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name ~= player.Name then
				
				local pChar = p.Character
				local pHRP = pChar and pChar:FindFirstChild("HumanoidRootPart")
				local pHM = pChar and pChar:FindFirstChildOfClass("Humanoid")

				local Char = player.Character
				local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
				local HM = Char and Char:FindFirstChildOfClass("Humanoid")

				if HM and pHM then
					if HM.Health > 0 and pHM.Health > 0 then
						
						local tool = Char and Char:FindFirstChildOfClass("Tool")
						local Handle = tool and tool:FindFirstChild("Handle")

						if tool and Handle then
							local Distance = (Handle.Position - pHRP.Position).Magnitude
							if Distance <= Settings2.LungeBotRange then
								tool:Activate()
							end
						end
					end
				end
			end
		end
	end
end)





local LookAt = function()
	local Char = player.Character

	--if not Char or not Char:FindFirstChild("HumanoidRootPart") or not Char:FindFirstChild("Humanoid") then return end


	local Target = nil

	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChild("Humanoid").Health ~= 0 then

			local pChar = p.Character
			local Distance = (Char:FindFirstChild("HumanoidRootPart").Position - pChar:FindFirstChild("HumanoidRootPart").Position).Magnitude

			if Distance <= Settings2.AimbotSliderValue then
				Settings2.AimbotSliderValue = Distance
				Target = pChar:FindFirstChild(Settings2.AimbotTargetPart)
			end
		end
	end


	if Target then
		local CharPos = Char:FindFirstChild("HumanoidRootPart").Position
		local TargetPos = Target.Position
		local Direction = Vector3.new(TargetPos.X, CharPos.Y, TargetPos.Z)
		Char:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(CharPos, Direction + Vector3.new(Settings2.AimbotOffset, 0, 0))
	end
end





local Jump = function()
	for _, p in pairs(Players:GetPlayers()) do
		if p.Name ~= player.Name then

			local pChar = p.Character
			local pHRP = pChar and pChar:FindFirstChild("HumanoidRootPart")
			local pHM = pChar and pChar:FindFirstChildOfClass("Humanoid")

			local Char = player.Character
			local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
			local HM = Char and Char:FindFirstChildOfClass("Humanoid")
			
			
			local Distance = (HRP.Position - pHRP.Position).Magnitude
			
			if Distance <= Settings2.JumpbotRange then
				if HM and pHM then
					if HM.Health > 0 and pHM.Health > 0 and pHM.Jumping then
						if HM then
							HM.Jump = true
						end
					end
				end
			end
		end
	end
end




RunService.Heartbeat:Connect(function()
	
	if Settings2.AimbotToggled then
		LookAt()
	end
	
	if Settings2.JumpbotToggle then
		Jump()
	end
	
end)

